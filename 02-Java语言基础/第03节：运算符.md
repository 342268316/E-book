# 第03节：运算符

上一节我们学校了变量与数据类型这节我们将学习与如何使用运算符

### 算数运算符
``` js
    加：+    减：-

    乘：*     除：/

    求余：%    //举个栗子：30%7 = 2

    自增：++   自减：- - 
```

### 赋值运算符

``` js
   加等于：+ =   //举个栗子：a + = c 等于 a = a + c 如下用法等同

   减等于：-  =    //同上

   乘等于：*  =

   除等于：/  = 

   模等于：%=   //就是假如a%=b相当于a=a%b；a%b就是a除以b的余数
```

### 关系运算符（得到结果为Boolean类型，true 或 false）

``` js
   大于：>   小于： <

   大于等于：> =

   小于等于：< =

   等于：==   不等于：！=
   
   全等与：===
```

### 布尔运算符

注意！布尔运算符两边的算子必须是布尔类型，整个表达式的运算结果也是一个布尔类型。

``` js
& 逻辑与 两边都是true，结果是true

| 逻辑或 一边是true,结果就是true

! 逻辑非 取反 !true –> false

^ 逻辑异或 两边只要是不一致就是true

&& 短路与 用法和 & 一样。 

|| 短路或 用法和 | 一样

```
#### &&短路与逻辑与的区别
* &&具有短路效果。如果左边结果是false，则右边不执行。
* &是无论左边是false还是true,右边都会执行。

|（逻辑或）和||（短路或）的区别类似


开发中常用&&和||，如果当需求要求无论左边的表达式是true还是false，右边的表达式必须执行，此时必须使用逻辑与，短路与做不到。

### 字符串连接运算符

``` js
//就以我们上一章学的hello world为例
public class Hello {
    public static void main(String[] args) {
        // 注释：在控制台输出Hello
        //用字符串连接运算符添加world
        System.out.println("Hello!" + "world");//控制台输出Hello world
    }
}
```

### 三目运算符

```js
//表达式格式
表达式1 ？ 表达式2：表达式3；//大致语义表达式1是真的吗？如果是返回表达式2如果不是返回表达式3
public static void main(String[] args) {

        System.out.println(1=2 ? "对！":"错！");//返回（错！）

    }
```

### 位运算符

#### 位运算符，这个”位”代表这什么？
位：二进制位简称“位”，是二进制记数系统中表示小于2的整数的符号，一般用1或 0表示，是具有相等概率的两种状态中的一种。二进制位的位数可表示一个机器字的字长，一个二进制位包含的信息量称为一比特。


Java中所支持的位运算符一共有7个
```js
&：按位与。当两位同时为1时才返回1。
|：按位或。只要有一位为1即可返回1。
~：按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。
^：按位异或。当两位相同时返回0，不同时返回1。
<<：左移运算符。
>>：右移运算符。
>>>：无符号右移运算符。
```

注（上面所说的两位相同，指的是参与运算的两位整数的补码，也就是存储在计算机中的形式）
```js

//下面举个例子（我们用8位来表示，最前面一位表示符号位）
int a = 3；
原码：0000 0011
反码：0000 0011
补码：0000 0011
//发现没，正数的原码，反码，补码都是一样的。其实反码跟补码都是为负数设计的。
int b = -3;
原码：1000 0011
反码：1111 1100
补码：1111 1101
//可以看到，负数的原码到反码是各位取反（这里说的取反就是0变1,1变0）符号位不变。
//反码到补码直接+1；

//& 同为1则为1 否则为0
//举个栗子：
5&9
5 补码 0000 0101
9 补码 0000 1001
结果 0000 0001
//也就是1；

//| 一位为1 则返回1
5|9
5 补码 0000 0101
9 补码 0000 1001
结果 0000 1101
//也就是13；

//~ 将操作数的每位取反
~-5
-5 补码 1111 1011
取反 0000 0100
//结果也就是4；

//^ 两位相同时返回0，不同时返回1
5^9
5 补码 0000 0101
9补码 0000 1001
结果 0000 1100
//也就是12；

//<<：左移运算符 将操作数的二进制码整体左移指定位数，右边空出的以0填充
-5<<2
首先算出-5的补码
1111 1011
左移两位 1110 1100 （将前面两位砍掉，整体左移，后面增加两位0。）
现在得到的是补码。
我们还要将补码转为原码。
其实就是原码->补码的反过程
先-1得到反码
1110 1011
然后取反得到原码
1001 0100
结果
-20；

//>>：右移运算符 将操作数的二进制码整体右移指定位数，左边空出的以符号位填充（如果是正数，就是以0填充。如果是负数，就是以1填充。）
-5>>2
-5的补码
1111 1011
右移两位得到
1111 1110
再转为原码
1000 0010
结果
-2；

//>>>无符号右移运算符 将操作数的二进制码整体右移指定位数，左边空出来的位总是以0填充。
-5>>>2
1111 1011
右移两位，空出来的以0填充，所以得到的结果总是正数
0011 1110
而且大的惊人 2的30次方-2 1073741822;
```

#### 注 关于移位运算还要遵循以下几个规则
对于低于Int类型（如byte、short、char）的操作数总是先自动类型转换为int类型后再移位。
对于Int类型的整数移位a>>b,当b>32时，系统会用b对32求余（因为int类型只有32位），得到的结果才是真正移位的位数。例如，a>>33和a>>1的结果是完全一样的，而a>>32和a相同。
对于long类型的整数移位a>>b，当b>64时，总是先用b对64求余（因为long类型是64位），得到的结果才是真正移位的位数。
当进行位移运算时，只要被移位的二进制码没有发生有效位的数字丢失（对于正数而言，通常指被移出的位全部都是0），可以发现左移n位就相当于乘以2的n次方，右移n位则是除以2的n次方。不仅如此，进行移位运算不会改变操作数本事，只是得到了一个新的运算结果，而原来操作数本事是不会改变的。

到此7种位运算符介绍完毕，虽然我们平时工作开发中可能不怎么用到，但是在看源码的时候，你会发现里面好多地方都在用这些运算符，所以弄清楚了有助于我们去看懂别人的代码。


接下来我们将开启下一节：分支语句