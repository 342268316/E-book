# 第06节：数据类型进阶

本节主要讲解数据类型当中的引用类型和字符编码的概括以及类型转换的理解

### 一、引用数据类型的概括
从基本类型构造而来的类和其他复杂数据类型。如:类、接口、数组和字符串。这种类型的变量并不包含类型的实例，而只是包含对实例的引用。 
引用类型的内存单元中只存放对象的地址，而对象本身存贮在内存堆中，只是简单的引用对象的地址。
一般在传参的时候用的最多。
### 二、基本数据类型和引用数据类型的区别
1）基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，而Java语言里面八种数据类型是这种存储模型；

2）引用类型的存储原理:引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的；

 “==”用于比较引用数据类型和基本数据类型时具有不同的功能：
比较基本数据类型，如果两个值相同，则结果为true
而在比较引用时，如果引用指向内存中的同一对象，结果为true）

首先，我定以两个String对象

``` js
Stringa="abc";

Stringb="abc";

```

然后

``` js
if(a==b){

System.out.println("a==b");

}else{

System.out.println("a!=b");}

```
程序输出a!=b

原因:a和b存储的地址是不相同的，a==b比较的是两个变量的地址

例2：定义两个基本类型

``` js
int a=4;

int b=4;

if(a==b){
    System.out.println("a==b");
    }

else

{System.out.println("a!=b");}

```
输出：a==b

原因：==比较的是两个变量的内容

猜想：不论是基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；而对于对象类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。
### 三、引用数据类型的列举即理解
引用类型包括：数组，用户定义的类、接口、委托，字符串，null类型，类。

* 数组（派生于System.Array） 
用户需定义以下类型： 
* 1.类：class（派生于System.Object）； 
* 2.接口：interface（接口不是一个“东西”，所以不存在派生于何处的问题。接口只是表示一种contract约定[contract]）。
* 3.委托：delegate（派生于System.Delegate）。 
* 4.字符串：string（System.String的别名）。

### 四、字符编码
为什么要编码:
因为计算机能理解的语言是二进制的（0,1），人类的语言（英文、中文以及其它语言）计算机是无法直接理解的，同样，计算机的二进制语言，人类也是无法直接理解的，所以需要进行转换，这个转换的过程就叫编解码。
由字符到字节叫编码，由字节到字符叫解码。

下面是六种字符编码的简单介绍:
* ASCII 编码:美国信息互换标准代码， 用一个字节来编码。
* ISO-8859-1 字符编码:是国际化标准组织位西欧语言制定的编码， 它用一个字节来为字符编码， 与 ASCII 编码兼容。
* GB2312 字符编码:它包括对简体中文字符的编码。
* GBK 字符编码:它是对 GB2312 编码的扩展， 收录了更多的中文字符。
* Unicode 字符编码:收录了全世界所有语言文字中的字符
* UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码。

### 五、类型转换
Java 语言是一种强类型的语言。强类型的语言有以下几个要求：

变量或常量必须有类型:要求声明变量或常量时必须声明类型，而且只能在声明以后才能使用。

赋值时类型必须一致:值的类型必须和变量或常量的类型完全一致。

运算时类型必须一致:参与运算的数据类型必须一致才能运算。


但是在实际的使用中，经常需要在不同类型的值之间进行操作，这就需要一种新的语法来适应这种需要，这个语法就是数据类型转换。
在数值处理这部分，计算机和现实的逻辑不太一样，对于现实来说，1和 1.0 没有什么区别，但是对于计算机来说，1 是整数类型，而 1.0 是小数类型，其在内存中的存储方式以及占用的空间都不一样，所以类型转换在计算机内部是必须的。

Java 语言中的数据类型转换有两种：

自动类型转换:编译器自动完成类型转换，不需要在程序中编写代码。

强制类型转换:强制编译器进行类型转换，必须在程序中编写代码。

由于基本数据类型中 boolean 类型不是数字型，所以基本数据类型的转换是出了 boolean 类型以外的其它 7 种类型之间的转换。下面来具体介绍两种类型转换的规则、适用场合以及使用时需要注意的问题。

#### 1、自动类型转换
自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM 自动完成。


转换规则：从存储范围小的类型到存储范围大的类型。
具体规则为：byte→short(char)→int→long→float→double

也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码：

``` js
byte  b  =  10;
short sh = b;这里在赋值时，JVM 首先将 b 的值转换为 short 类型，然后再赋值给 sh。
```
在类型转换时可以跳跃。示例代码：

``` js
byte  b1  =  100;
int  n  =  b1;

```
注意问题:在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。
注意在类型转换的时候,默认是int类型

#### 2、强制类型转换
强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。

转换规则:从存储范围大的类型到存储范围小的类型。

具体规则为：double→float→long→int→short(char)→byte

语法格式为：(转换到的类型)需要转换的值

示例代码：
``` js
double  d  =  3.10;
int  n  =  (int)d;
```
这里将 double 类型的变量 d 强制转换成 int 类型，然后赋值给变量 n。需要说明的是小数强制转换为整数，采用的是“去 1 法”，也就是无条件的舍弃小数点的所有数字，则以上转换出的结果是 3。整数强制转换为整数时取数字的低位，例如 int 类型的变量转换为 byte 类型时，则只去 int 类型的低 8 位(也就是最后一个字节)的值。
示例代码：
``` js
int  n  =  123;
byte  b  =  (byte)n;
int  m  =  1234;
byte  b1  =  (byte)m;
```
则 b 的值还是 123，而 b1 的值为-46。b1 的计算方法如下：m 的值转换为二进制是10011010010，取该数字低8位的值作为b1的值，则b1的二进制值是11010010，按照机器数的规定，最高位是符号位，1 代表负数，在计算机中负数存储的是补码，则该负数的原码是 10101110，该值就是十进制的-46。
注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。